\documentclass[acmsmall,screen,nonacm,review]{acmart}
\usepackage{tcolorbox}
\usepackage{minted}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{subcaption}
\begin{comment}
  TODO: 
  -reduce page count?
  -page layout

\end{comment}

\definecolor{bg}{rgb}{0.97,0.97,0.97}

\author{}
\email{}



\begin{document}


\title{An Introduction to HLSL}

\begin{abstract}

This document is an introduction to the shading language HLSL, made for the course ``Seminar Modern Programming Languages'' at Ruhr-University Bochum 2025/2026.
It starts with a brief look at the history of HLSL, which explains the purpose of the language.
Following this are explanations of HLSL concepts, including data types, semantics and flow control.
The last part is about the graphics pipeline. The pipeline stages are explained by looking at an animated cube and
observing the changes made by each stage. Each stage includes a brief explanation of the stage, a frame of the cube and 
a snippet of the shader code.

\noindent It is possible, that some concepts mentionend are not further explained or details are omitted, because they would go beyond the scope of this course. 
Concepts that are not explained, can be found in the conclusion.
\end{abstract}

\maketitle

\section{History of HLSL}
When GPU's were introduced, each GPU required dedicated code. In 2002\cite{Direct3DGettingStarted}, Microsoft released DirectX 9.0 and with it the High Level Shader Language\cite{DirectX2003}.\@
The goal was to provide a flexible and developer-friendly environment that abstracts the different GPU implementations\cite{DirectX2003}.
HLSL is based on the c programming language\cite{DirectX2003} and adds additional concepts designed for programming the graphics pipeline. 
The language implements multiple versions of shader models, each being an extension of the previous version\cite{HLSLShaderModel}.
The latest shader model is the 6th version, which is used by Direct3D 12. 



\section{Data Types}
HLSL supports various data types. This section gives an overview over the different Data Types.

\subsection{Scalar}
Scalar variables use a single component of a register. There are different kinds of scalar data types. Standard types like 
integer, signed and unsigned, floating points and bools are available. There are also less common types like snorm float or unorm float. 
These are normalized floating point numbers. A snorm float can take any value in the intervall [-1,1] and unorm float can take values in the intervall [0,1].
Unorm floats are often used for colors.

\noindent \textit{Examples:}
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg]{hlsl}
uint   AnUnsignedInteger;
double ADoublePrecisionFloatingPoint;
unorm float AnUnsignedNormalizedFloatingPoint;
\end{minted}


\subsection{Vector}
Vectors are variables that use up to 4 components\cite{HLSLVector}. The type can be any of the scalar data types. A vector can be declared in two ways:

\noindent Declaration with a template: \colorbox{bg}{\textbf{vector}<Type, Components = [1,4]>}

\noindent \textit{Examples:}
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg]{hlsl}
vector<float, 4> AFourComponentFloat;
vector<float, 1> ASingleComponentFloat; //Equal to a scalar float
\end{minted}
\pagebreak
\noindent Declaration as a type: \colorbox{bg}{\textbf{float[n]}, where n is a number in the intervall [1,4].}

\noindent \textit{Examples:}
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg]{hlsl}
float4 vPosition;
float4 Color;
float3 Normal;
\end{minted}

\noindent Accessing a component can be done by using the structure operator ``\textbf{.}''\cite{HLSLComponentMath} followed by the letters xyzw or rgba.

\noindent\textit{Examples:}
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg]{hlsl}
Vector2.xy  //accesses the first and second component
Vector3.rgb //accesses the first second and third component
Vector4.yzw //accesses the second, third and fourth component
\end{minted}

\noindent The letters \textit{xyzw} or \textit{rgba} correspond to the components of a Vector.


\subsection{Matrix}
Matrices are two dimensional grids made of scalar components\cite{HLSLMatrix}. 
HLSL allows matrices with one to four columns and rows, respectively.
A single component of a matrix can be accessed with ``\verb|._mRC|'', where R and C denote the positions inside the matrix.

Declaration of Matrices:\colorbox{bg}{Type[Rows]x[Columns]}

\noindent \textit{Examples:}
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg]{hlsl}
float4x4 RollRotationMatrix = {   //A 4 by 4 Matrix
  1.0f,0.0f,0.0f,0.0f,
  0.0f,cos(RadAngle),-sin(RadAngle),0.0f,
  0.0f,sin(RadAngle),cos(RadAngle),0.0f,
  0.0f,0.0f,0.0f,1.0f};
matrix<uint,3,3> AnUnsignedInt3x3Matrix;
float4 FirstRow = RollRotationMatrix._m00_m01_m02_m03; 
\end{minted}


\subsection{Buffers}
A pipeline stage might need more than the vertex data to calculate the output.
The GPU often has its own, dedicated memory, which is not directly accessible by the CPU.\@ The GPU is responsible for fetching the data from the CPU and write it into its own memory.
At this point, buffer objects are used to access this data.
Each pipeline stage is able to reference a fixed amount of buffers. There are multiple types of buffers. 
There are structured buffers, which store multiple instances of a struct, or constant buffers, that store data, which is constant during the shader execution.
Compute Shaders require buffers with unordered acces, which allows read and write access from multiple threads.

\noindent Even though buffers look similar to structs, they are different.
Structs are used to group data within a shader, whereas buffers contain data coming from the CPU.\@

\noindent \textit{Examples:} 
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg]{hlsl}
RWTexture2D <float4> AReadWriteTextureBuffer;
//The Buffer stores instances of the struct T
StructuredBuffer<T> AStructuredBuffer; 
cbuffer AConstantBuffer{                          
  float RotationAngle;
  float Width;
  float Height;
};
\end{minted}

\subsection{Struct}
A struct is a collection of data, grouped together in memory, and works like a struct in c.

\section{Semantics}
Semantics are strings attached to the input and output variables of shaders\cite{HLSLSemantic}.
These strings are used by the graphics pipeline to identify the meaning of the variable.
If there are multiple variables with the same semantic meaning, an integer can be appended to the semantic.

\noindent \textit{Examples:}
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg]{hlsl}
  float4 Position : POSITION; //Position is treated as a Vertex Position.
  float2 vPosition : VPOS;    //vPosition is treated as a Pixel Location. 
  float3 Color : COLOR1;      //Color is treated as a Color.
\end{minted}

\section{Flow Control}
HLSL is a language for GPUs. GPUs are made for Single Instruction Multiple Data (SIMD) and parallel execution.
This makes the flow control different to CPU flow control.
Branches on the CPU are simple, because comparisons operate on a single value.
Therefore, the CPU is able to use the result to choose which branch to take.
GPUs are SIMD and operate on multiple values. Branching can no longer be decided by a single value,
since different branches would require different instructions, which does not work with SIMD.\@\cite{NvidiaFlowControl}
Loops have to wait, until all loop conditions are equal to 0.
HLSL uses c's flow control syntax, but adds additional options to it, which can specify how a branch is evaluated.

\noindent The \textbf{discard} keyword is added by HLSL.\@ It can only be used in a pixel shader. 
If a discard statement is executed, the shader will not output the result of the pixel\cite{HLSLDiscard}.

\noindent \textit{Example:} 
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg]{hlsl}
  if(input.Position.z > 0){
    discard; //No Pixel Shader ouput when z > 0
  }
\end{minted}

\noindent HLSL adds two attributes to \textbf{if}-statements:
\begin{itemize}
  \item \textbf{flatten}: Executes the \textit{true} and \textit{false} side of the if-statement and decides, which one to use, based on the condition\cite{HLSLif}. 
  
  \item \textbf{branch}: Executes only one side, depending on the condition\cite{HLSLif}.
\end{itemize}

\section{Graphics Pipeline}
The picture on the left shows an example output of a cube made with the graphics pipeline.
This section introduces the Direct3D11 graphics pipeline and shows, how the stages were used to produce the example.
The diagram on the right illustrates the Direct3D11 pipeline and the order in which the data passes the stages.

\noindent \includegraphics[height=0.16\textheight]{Assets/FinalImage.png} \includegraphics[height=0.2\textheight]{Assets/D3D11-Pipeline-Stages.png}


\subsection{CPU Data}
The process starts on the CPU.\@ The CPU has to decide what data the GPU has to transform and in which way.
The first step is to pass the data of the cube to the GPU.\@ This is done by creating a Vertex Buffer and an Index Buffer, 
which contain the necessary information for the input assembler. 
The vertex and index data, passed by the CPU, describes 8 vertices and 12 triangles. 
Each vertex containts a position and a color.


\subsection{Required Pipeline Stages}
To see an image from the data that has been passed to the CPU, a few pipeline stages are required to be active\cite{HLSLVS}.
In the cube example, the input assembler, vertex shader, rasterizer and pixel shader are active. At that point, the shaders only pass the data to the next stage, without modifying it.

\subsection{Input Assembler Stage}
The input assembler stage(IA) receives the index and vertex buffers from the CPU.\@ It then uses these buffers, to create primitves (shapes).
Primitves are described by one or more vertices. To find the vertices for a primitve, the IA reads consecutive indices from the index buffer. 
The indices point to vertices in the vertex buffer and allow the IA to get the correct vertices. 
When all indices are processed, the primitives are passed to the vertex shader stage. 

\noindent This is the output of the input assembler and only passing the data through the other stages:

\noindent \includegraphics[height= 0.16\textheight]{Assets/PassThrough.png}


\subsection{Vertex Shader Stage}
The vertex shader stage is the first stage after the input assembler stage and operates on the vertices of the primitives. At that stage, the final positions of the vertices can be calculated.
This stage is where rotations, scaling and translations happen. The vertex shader is executed for every vertex passed by the input assembler\cite{HLSLVS}, 
but operates only at one at a time. 

\noindent This is the stage, where the cube is being rotated, scaled down and then projected with an orthographic projection.  

\noindent \includegraphics[height= 0.16\textheight]{Assets/VertexShader.png}


VertexShader
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg,linenos]{hlsl}
#define PI 3.14159265359
#define DegreeToRad(x) ((x)*PI/180)
uniform float RotationAngle : register(b0[0]);
uniform float Width : register(b0[1]);
uniform float Height: register(b0[2]);
vs_output VSEntry(const vs_input input){
  vs_output Output;
  float4 Input = float4(input.vPosition,1);
  float4 ScalingVec = {1.1f,1.1f,1.1f,1};
  float4x4 OrthographicProjectionMatrix = {
    1.0f,0.0f,0.0f,0.0f,
    0.0f,1.0f,0.0f,0.0f,
    0.0f,0.0f,(2.0f/3.0f),3.0f/2.0f,
    0.0f,0.0f,0.0f,1.0f};
  Input = Input * ScalingVec;
  Input = RotationYaw(Input,RotationAngle);
  Input = RotationPitch(Input,RotationAngle);
  Input = RotationRoll(Input,0);
  Input.x /= (Width/Height);
  Input = mul(OrthographicProjectionMatrix,Input);
  Output.vPosition = Input; Output.Color =  input.Color;
  return Output;
}
\end{minted}

\noindent This is the main function of the vertex shader. Most of the code is simple, but there are some interesting lines.

\noindent Variables declared as \textbf{uniform} have the same value for all invokations within a render pass and are constant.\cite{HLSLVars}

\noindent HLSL has a preprocessor and allows macros. \textbf{DegreeToRad} is such a macro and converts angles from degrees into radians.

\noindent The position data is normalized, in the intervall [-1,1], but the image it is rendered to is not square.
Without line 22, the cube would be stretched along the x-axis. To compensate for that, the x coordinates must be divided by the aspect ratio (Width/Height).

\noindent Line 23 is interesting, because it is using an intrinsic. Intrinsics are functions that map directly to assembly instructions. 
The \textbf{mul} intrinsic has to be used for efficient matrix multiplication.

\noindent The main functions of shaders specify, which data is required from the previous stage. 
The return value of the main function is, what is passed to the next stage. If a single value is required by the following stage, it is sufficient to simply return this value.
Everytime more than a single value is required, the function has to return a struct containing the data. 

\noindent In the example, the new position and the input color are passed to the next stage.



\subsection{Tessellation Stages}
The tessellation stages use the vertices from the vertex shader and interprets them as groups of vertices, called patches. Each patch is describing a shape.
The amount of vertices in a patch is defined by the shape. The tessellation stages are three stages, which need to be enabled at the same time. 
These three stages divide each patch into smaller patches.

\noindent The \textbf{hull shader} stage is the first of the three stages. 
It takes a patch as input and outputs control points, which are used by the domain shader, and patch-constant data, which is used by the tessellator.

\noindent The \textbf{tessellator} stage takes the patch-constant data and calculates UV(W)-values. Each UV(W)-value can be used by the domain shader to create a new vertex.

\noindent The \textbf{domain shader} stage combines the control points from the hull shader and the UV(W)-values from the tessellator.
By interpolating between control points with the UV(W)-values, new vertices can be created. 
The UV(W)-values are often used to calculate new vertex positions, but it is also possible to calculate a color using these values. 
\noindent This is the cube, after tessellation:

\noindent \includegraphics[height= 0.16\textheight]{Assets/Tesselator.png}


Hull Shader and 
Domain Shader
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg,linenos]{hlsl}
ConstantOutputType PatchConstantFunction(
  InputPatch<HsInput,3> inputPatch, 
  uint PatchID : SV_PrimitiveID)
{
  ConstantOutputType Output;
  Output.Edges[0] = 1; Output.Edges[1] = 1;
  Output.Edges[2] = 1; Output.inside = 2;	
  return Output;
}


[domain("tri")]
[outputcontrolpoints(3)]
[patchconstantfunc("PatchConstantFunction")]
PatchControlPoint HSEntry(
  InputPatch<HsInput,3>patch, 
  uint PointID : SV_OutputControlPointID, 
  uint PatchID : SV_PrimitiveID)
{
	PatchControlPoint Output;
	Output.Color = patch[PointID].Color;
	Output.Position = patch[PointID].Position;
	return Output;
}


[domain("tri")]
DSOutput DSEntry(
  ConstantOutputType input, 
  float3 UVWCoord : SV_DomainLocation, 
  const OutputPatch<PatchControlPoint,3> patch)
{
  DSOutput Output;
  Output.Position = UVWCoord.x * patch[0].Position 
    + UVWCoord.y * patch[1].Position + UVWCoord.z * patch[2].Position;
  Output.Color = UVWCoord.x * patch[0].Color+ UVWCoord.y * patch[1].Color
    + UVWCoord.z * patch[2].Color;
  Output.Color.w = 1.0f;
  return Output;
}
\end{minted}

\noindent The hull shader provides two functions. The patch-constant function, which generates the patch-constant data, 
and the main function, which generates the control-points for the patch.

\noindent The main function of the domain shader calculates the new vertices, which contain a position and a color.

\noindent Before each main function, properties must be declared within square brackets.
The hull shader needs to know the shape of the patch, how many control points it should output and which function is used to calculate the patch-constant data.
The domain shader also needs to know the patch shape.

\subsection{Geometry Shader Stage}
The geometry shader is the last stage before the rasterizer and can be used to generate new primitives. Unlike the previous stages, which operate on single vertices, geometry shaders
are invoked for each primitive, coming from the previous stage\cite{HLSLGS}. 
The data from the input primitives can now be used to generate new vertices, which define the new primitives.
The amount of generated vertices is not fixed, but a static upper limit must be defined.

\noindent \includegraphics[height= 0.16\textheight]{Assets/GeometryShader.png}


Geometry Shader
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg,linenos]{hlsl}
[maxvertexcount(9)]
void GSEntry(
  triangle GSInput InputTri[3] : SV_Position, 
  inout TriangleStream<GSOutput> OutStream)
{
  float4 MidPoint = (InputTri[0].Position + InputTri[1].Position 
    + InputTri[2].Position)/3.0f;
  float4 MidPointColor = float4(InputTri[0].Color + InputTri[1].Color 
    + InputTri[2].Color)/3.0f;
  GSOutput Output;

  Output.Pos = InputTri[0].Position;
  Output.Color = InputTri[0].Color;
  OutStream.Append(Output);
  Output.Pos = InputTri[1].Position;
  Output.Color = InputTri[1].Color;
  OutStream.Append(Output);
  Output.Pos = MidPoint;
  Output.Color = MidPointColor;
  OutStream.Append(Output);
  OutStream.RestartStrip();
}
\end{minted}

\noindent The geometry shaders way of outputting data is different than in other stages. 
Instead of returning a value, it takes a stream as input and outputs the new primitives on the stream.

\noindent The geometry shader divides the cube even further.
The input primitves are used to calculate the triangles midpoint. This midpoint is then used to generate
three triangles, each made by the midpoint and two vertices from the input,
which are then appended to the output stream as a triangle strip.

\noindent The geometry shader output is passed down to the rasterizer stage.

\subsection{Rasterizer Stage}
This stage is the last stage before the pixel shader.
Because the primitves are described by vectors in the preceding stages,
the rasterizer has to transform the data into a raster image. 
The rasterizer takes the primitives and calculates which pixels in the image are covered by a primitive.
There are different rasterization rules, depending on the primitve type, multisampling and anti-aliasing.

\noindent The rasterizer cannot be programmed with a shader, like the other stages, but some settings can be set by the CPU.\@
It is possible to specify if the primitives are filled or a wireframe, enabling or disabling multisampling and enabling or disabling anti-aliasing.
More settings can be found in the Direct3D reference.
\begin{figure}[h]
  \begin{minipage}{.49\textwidth}
    \includegraphics[height= 0.16\textheight]{Assets/GeometryShader.png}

    \hspace{1.5cm}\textit{Rasterizer set to wireframe}
  \end{minipage}
  \begin{minipage}{0.49\textwidth}
    \includegraphics[height= 0.16\textheight]{Assets/Rasterizer.png}

    \hspace{2cm}\textit{Rasterizer set to fill}
  \end{minipage}
\end{figure}


\noindent Notice, that the color seems to be dissapearing in wireframe mode on the bottom right. This is because the rasterizer is not only deciding, which pixels are filled,
it also does other things like interpolating between per-vertex data. The vertex on the bottom right is the same color as the background 
and the closer a pixel gets to this vertex, the more the pixel's color is influenced by the vertex color. 
It is still visible in filled mode, but it's not as obvious as in wireframe mode.


\subsection{Pixel Shader Stage}
After the rasterizer generated an image from the primitives, the pixel shader is invoked for each pixel and 
combines textures, buffer data and per-vertex values\cite{HLSLPS} to calculate color- and optional depth-data of the pixel in the image.

\noindent \includegraphics[height= 0.16\textheight]{Assets/PixelShader.png}

Pixel Shader
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg,linenos]{hlsl}
ps_output PSEntry(const ps_input input){
  ps_output output;
  output.Color = input.Color;
  [branch]if(input.Color.r == 1.0f){
    output.Color = float4(ColorR,ColorG,ColorB,ColorA);
  }
  [flatten]if(input.Color.r == 0.0f){
    output.Color = float4(ColorR,ColorG,ColorB,ColorA);
  }
  return output;
}
\end{minted}

\noindent This pixel shader animates all pixels, where the red channel is equal to 1 or 0;
The color of the animation comes from a constant buffer. The CPU is responsible for updating the color. 

\noindent Notice, that the Color[X] variables are from the constant buffer and can be used like global variables.

\subsection{Output Merger Stage}
The last graphics pipeline stage is the output merger. Its job is to generate the final pixel color\cite{HLSLOMS}, 
by blending the color output of the pixel shader with the depth data. If no depth data exists, the final pixel color
is the same color, as the one coming from the pixel shader.

\noindent This is the image after the output merger stage:

\noindent \includegraphics[height= 0.16\textheight]{Assets/PixelShader.png}

\subsection{Compute Shader}

Direct3D11 introduced computer shaders. These shaders are general purpose shaders, which are not part of the graphics pipeline.
Compute shaders can use the GPU for general-purpose computations, which are not necessarily graphics related.

\noindent Even though compute shaders are independent from the graphics pipeline, both can be used together.

\noindent Compute shaders can be used for post-processing effects. 
The example uses a compute shader, that scales the red channel down for every pixel in the image, excluding all pixels with an rgb value of 0xffffff.

\noindent This is the cube after the computer shader:

\noindent \includegraphics[height= 0.16\textheight]{Assets/ComputeShader.png}

ComputerShader
\begin{minted}[xleftmargin=0.3cm,bgcolor=bg,linenos]{hlsl}
RWTexture2D <unorm float4> SwapChainImageCopy : register(u0);

[numthreads(1,1,1)]
void CSEntry(uint3 GroupID: SV_GroupID){
  uint2 Coordinate = uint2(GroupID.x,GroupID.y);
  float4 Color = SwapChainImageCopy[Coordinate];
  if(distance(Color.xyz,float3(1,1,1)) != 0){
    Color.r *= 0.7f;
  }
  SwapChainImageCopy[Coordinate] = Color;
}
\end{minted}


\noindent Compute shaders need to specify how many threads 
are spawned, when the shader is invoked. This is done by providing three values, x, y and z, in the \textbf{numthreads} property\cite{HLSLCreateCS}.

\subsection{Final Image}
After all these steps the image can be rendered to the screen.

\includegraphics[height= 0.16\textheight]{Assets/FinalImage.png}


\section{Conclusion}
This introduction gives a broad overview of HLSL's data types, semantics, flow control and the graphics pipeline.
However, there are topics that couldn't be introduced, but are valuable for a deeper undestanding of HLSL and the graphics pipeline.

\noindent Here are some topics that were either briefly or not explained:

\begin{itemize}
  \item GPU architecture: GPU registers, SIMD
  \item Computer Graphics Concepts: anti-aliasing, primitve topology, UV-Coordinates, subdivision, Depth Buffering, multisampling, interpolation
  \item miscellaneuos: control-points, render pass, normalized data, domain, aspect ratio
\end{itemize}
\pagebreak

\bibliographystyle{ACM-Reference-Format}
\bibliography{Sources}
\end{document}




