\documentclass[acmsmall,screen,nonacm,review]{acmart}
\usepackage{minted}


\title{An Introduction to HLSL}

\begin{document}
\maketitle

\section{Introduction}

\section{HLSL Language}
The HLSL Language is similar to the c programming language.
A lot of it has been taken over from c, but some new things, that help programming the graphics pipeline, have been added.
This section describes the language syntax.

\subsection{Variable Syntax}
In HLSL variables are declared with this syntax:

\small[Storage\_Class] [Type\_Modifier] Type Name[Index] [: Semantic] [: Packoffset] [: Register]; [Annotations] [= Initial\_Value] 
\normalsize

Storage\_Class:

Parameter that gives the compiler a hint about scope and lifetime.

Examples:

static: The variable is initialized once and persist after leaving the scope.

uniform: The variable's data remains the same throughout the execution of the shader.


Type\_Modifier:

Optional modifier.

Example:

const: The variable cannot be changed.

Type:
The type of the data being stored in the variable. It can be any of the HLSL Data Types.

Examples:
int: signed 32-bit integer
dword: unsigned 32-bit integer  
double: 64-bit floating point number

Name:

An ASCII String that uniquely identifies the variable.

Index:

Providing a positive Integer as the Index makes the variable an Array.

Examples:
\begin{minted}{hlsl}
  float MyArray1[3] //An Array of 3 floats.
  uint MyArray2[32] //An Array of 32 uints. 
\end{minted}


Semantic:

Semantics are Strings attached to the input and output variables of shaders.
These Strings are used by the graphics pipeline to identify the meaning of the variable.
If there are multiple variables with the same semantic meaning, an Integer can be appended to the semantic.

Examples:
\begin{minted}{hlsl}
  float4 Position : POSITION; //Position is treated as a Vertex Position.
  float2 vPosition : VPOS;    //vPosition is treated as a Pixel Location. 
  float3 Color : COLOR1;      //Color is treated as a Color.
\end{minted}


Packoffset:

Each register has 4 32-bit components. When passing variables in a constant buffer to the GPU, some variables may not use all 4 subcomponents.
If each variable uses only one of those components and has its own register, a lot of memory would be wasted.
To avoid wasting memory, data can be packed into registers, if the variables components are small enough to fully fit into the register.

To retrieve packed data and store it into a variable, packoffset needs the buffer slot and component slot, from which the data should be used.

Examples:

Valid:

\begin{minted}{hlsl}
  cbuffer CBuffer{
	float RotationAngle : packoffset(c0.x);
	float Width         : packoffset(c0.y);
	float Height        : packoffset(c0.z);
	float ColorR        : packoffset(c1.x);
	float ColorG        : packoffset(c1.y);
	float ColorB        : packoffset(c1.z);
	float ColorA        : packoffset(c1.w);
};
\end{minted}

Invalid:
\begin{minted}{hlsl}
  cbuffer{
      float2 x: packoffset(c0);   // x uses 2 components 
      float3 y: packoffset(c0.z); // y uses 3 components
  }
\end{minted}

Register:

Assigns one or more registers to a variable. The register can be specified by the type, the buffer slot index and a subcomponent.

\begin{minted}{hlsl}
  float RotationAngle : register(b0[0]); //Constant Buffer at Index 0, Data at offset 0
  float Width         : register(b0[1]); //Constant Buffer at Index 0, Data at offset 1
  float Height        : register(b0[2]); //Constant Buffer at Index 0, Data at offset 2
\end{minted}

Annotations:

Additional information added to a variable. Annotations are used by Effects.

Examples from the documentation:
\begin{minted}{hlsl}
  int j <int bambam=30; string blacksheep="Goodbye There";> = 5 ;
  float y <float y=2.3;> = 2.3, z <float y=1.3;> = 1.3 ;
  half w <half GlobalW = 3.62;>;
\end{minted}

Initial\_Value:

The Value, that the variable is initialized with.

\subsection{Data Types}
HLSL supports various data types. This section gives an overview over the different Data Types.
\subsubsection{Scalar}
Scalar variables use a single component of a register. There are different kinds of scalar data types.

The main ones are:

-bool : true or false
-int : 32-bit signed integer
-uint : 32-bit unsigned integer
-half : 16-bit floating point
-float : 32-bit floating point
-double : 64-bit floating point
-snorm float: 32-bit signed-normalized float in the intervall[-1,1]
-unorm float: 32-bit unsigned-normalized float in the intervall[0,1]

Examples:

\begin{minted}{hlsl}
  float RotationAngle;
  bool  RedChannelActive;
\end{minted}

\subsubsection{Vector}
Vector's are variables that use up to 4 components. The type can be any of the scalar data types. A vector can be declared in two ways.

Declaration with a template:

\begin{minted}{hlsl}
  vector<Type = float, Components = 4> Color; // A four component float

  vector<float, 1> RotationAngle; // A single component float, the same as a scalar float
\end{minted}

Type declaration:

HLSL provides predefined macros for vectors of built-in scalar types.
This simplifies the vector declarations.

Macro example:
\begin{minted}{hlsl}
  #define float4 vector<float,4> //predefined macro
  
  float4 Var1;

  //expands to
  vector<float,4> Var1;
\end{minted}


Examples:
\begin{minted}{hlsl}
  float4 vPosition :SV_Position;
	float4 Color : COLOR;
	float3 Normal : NORMAL;
\end{minted}

\subsubsection{Matrix}

\subsubsection{Buffer}
\subsubsection{Struct}
\subsection{Semantics}
\subsection{Flow Control}
\subsection{Functions}
\subsection{Intrinsics}
\subsection{Shader Models}

\section{Graphics Pipeline}
\subsection{Input Assembler Stage}
\subsection{Vertex Shader Stage}
\subsection{Tesselation Stage}
\subsubsection{Hull Shader Stage}
\subsubsection{Domain Shader Stage}
\subsection{Geometry Shader Stage}
\subsection{Rasterizer Stage}
\subsection{Pixel Shader Stage}
\subsection{Output Merger Stage}

\section{Passing Data from the CPU to GPU}
\subsection{Constant Buffer}
\subsection{Unordered Access View}

\end{document}